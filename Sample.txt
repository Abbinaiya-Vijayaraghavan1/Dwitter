pragma solidity >=0.5.1 <0.7.0;

contract DwitterMain {
   address owner;
  
   constructor() public{        //constructor
       owner = msg.sender;
   }
   
    struct Dweet {
        uint id;
        string content;
        uint timestamp;
        uint upvotes;
        uint reports;
        string[] hashtags;
       
    }
   
    struct User{
        uint id;
        address pkey;
        string firstname;
        string lastname;
        string userName;
        string bio;
       // string photoUrl;  //profile picture
    }
   
    uint public dweet_count=0;
    uint public user_count=0;
   
    uint date = block.timestamp;
   
    Dweet[] public dweets;
    User[] public users;
   
   
    mapping(uint => address) public dweetToAuthor;  //maps dweet's id to author's address
    mapping(address => uint) public dweetCountAuthor; //stores number of dweets by individual author
    mapping(address => string) public userChecker; //
   
   event NewUserAdd (
       string _userName,
       address _pkey
       );
       
     event NewDweetAdd (
         string _content,
         uint256 timestamp
        //string[] _hashtagList
        
        )  ;
        
   
   
     modifier onlyOwner(){
         require(msg.sender == owner);
         _;
     }
   
     modifier userNameAlreadyExists(string memory _userName){
        //use a bloom structure ?
        // or iterate through all users in array
        //require(userChecker[msg.sender] == bytes4(0x0));
        
        
           _;    
    }
   
    function addNewUser(string memory _firstName, string memory _lastName, string memory _userName, string memory _bio, string memory _url) public userNameAlreadyExists(_userName) onlyOwner{
        
        //should we have only one account per user ?
        //if yes, check if user already exists using public key


        users[user_count++]= User(user_count++, msg.sender, _firstName, _lastName, _userName, _bio);
        emit NewUserAdd(
             _userName,
             msg.sender
            ); // fire event new user added
       
       
    }
   
    function addNewDweet(string memory _content, string[] memory _hashtagList) public{
        uint dweetId = dweet_count++;
        //string[] memory hashtagList = identifyHashtags(_content);  
       
        dweets[dweetId]= Dweet(dweetId, _content, block.timestamp, 0, 0, _hashtagList);
         emit NewDweetAdd (
             _content,
             block.timestamp
            // hashtagList 
             );    //fire event new dweet added
       
        dweetToAuthor[dweetId] = msg.sender;
        dweetCountAuthor[msg.sender]++;
      
       
    }
   
   
    /*function identifyHashtags(string memory _content) pure private returns(string [] memory) {
       bytes memory contentBytes = bytes(_content) ;
       //check the first character of each word
       
     
       
      /* if(keccak256(abi.encodePacked(first)) == keccak256(abi.encodePacked("#")))
       {
           
       }
      */
   
        
    
   
}

